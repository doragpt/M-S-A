It seems there are multiple API endpoints with errors related to the data format and missing or incorrect query parameters, resulting in a 400 BAD REQUEST. Here are the main issues that need attention:

/api/history/optimized Endpoint: This endpoint is throwing a 400 error which usually indicates a client-side error, such as missing required parameters.

Unexpected API Response Formats: The front-end is expecting a certain structure in the API responses, but it seems the responses might not be matching this expectation. This suggests a mismatch between the API's output and the front-end's expected input.

Proposed Solution:
Enhance Error Handling: Ensure that required query parameters are correctly checked and informative error responses are returned when they are missing.

Check API Response Structure: Make sure that the API response structures match what the front-end is expecting.

Let's enhance the /api/history/optimized endpoint for better handling of missing parameters and fix the response structure to align with the expected format on the front end.

Proposed Changes to api_endpoints.py
Below, I will enhance the function to ensure that all required parameters are checked and provide a default response structure that should align with the front-end expectations.

def get_store_history_optimized():
    """
    指定した店舗の履歴データを取得するエンドポイント（最適化版）
    クエリパラメータ:
    - store_name: 店舗名（必須）
    - start_date: 開始日（YYYY-MM-DD）
    - end_date: 終了日（YYYY-MM-DD）
    - interval: データ間隔（分、デフォルト: 60）
    """
    store_name = request.args.get('store_name', '')
    if not store_name:
        return error_response("店舗名が指定されていません", 400)
    # 日付範囲のパース
    start_date_str = request.args.get('start_date', '')
    end_date_str = request.args.get('end_date', '')
    interval = min(request.args.get('interval', 60, type=int), 1440)  # 最大値は1日（1440分）
    try:
        jst = pytz.timezone('Asia/Tokyo')
        now = datetime.now(jst)
        # デフォルト: 過去24時間
        if not start_date_str:
            start_date = (now - timedelta(hours=24)).replace(tzinfo=None)
        else:
            start_date = datetime.strptime(start_date_str, '%Y-%m-%d')
        if not end_date_str:
            end_date = now.replace(tzinfo=None)
        else:
            end_date = datetime.strptime(end_date_str, '%Y-%m-%d')
            # 終了日は23:59:59に設定
            end_date = end_date.replace(hour=23, minute=59, second=59)
        # 期間が30日以上の場合はintervalを大きく
        if (end_date - start_date).days > 30:
            interval = max(interval, 240)  # 4時間以上
        # SQLクエリ構築（時間でグループ化）
        query = """
        SELECT 
            CAST(strftime('%s', timestamp) / (? * 60) * (? * 60) AS INTEGER) AS interval_timestamp,
            AVG(CASE WHEN total_staff = 0 THEN 0 ELSE CAST(working_staff AS FLOAT) / total_staff END) AS avg_operation_rate,
            MAX(CASE WHEN total_staff = 0 THEN 0 ELSE CAST(working_staff AS FLOAT) / total_staff END) AS max_operation_rate,
            MIN(CASE WHEN total_staff = 0 THEN 0 ELSE CAST(working_staff AS FLOAT) / total_staff END) AS min_operation_rate,
            AVG(working_staff) AS avg_working_staff,
            AVG(active_staff) AS avg_active_staff,
            COUNT(*) AS sample_count,
            MAX(timestamp) AS latest_timestamp
        FROM store_status
        WHERE store_name = ?
        AND timestamp BETWEEN ? AND ?
        GROUP BY interval_timestamp
        ORDER BY interval_timestamp
        """
        conn = get_db_connection()
        results = conn.execute(query, [interval, interval, store_name, start_date, end_date]).fetchall()
        conn.close()
        # 結果の整形
        history_data = []
        for row in results:
            # Unixタイムスタンプを日時に変換
            timestamp = datetime.fromtimestamp(row['interval_timestamp'])
            history_data.append({
                'timestamp': timestamp.isoformat(),
                'avg_operation_rate': row['avg_operation_rate'],
                'max_operation_rate': row['max_operation_rate'],
                'min_operation_rate': row['min_operation_rate'],
                'avg_working_staff': row['avg_working_staff'],
                'avg_active_staff': row['avg_active_staff'],
                'sample_count': row['sample_count']
            })
        return api_response({
            'store_name': store_name,
            'start_date': start_date.isoformat(),
            'end_date': end_date.isoformat(),
            'interval_minutes': interval,
            'data_points': len(history_data),
            'history': history_data
        }, 200, 'success')
    except Exception as e:
        logger.error(f"店舗履歴データ取得エラー: {e}")
        return error_response(f"履歴データ取得中にエラーが発生しました: {str(e)}", 500)