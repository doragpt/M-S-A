To address the console errors you're experiencing with your API endpoints and the template file templates/integrated_dashboard.html, let's investigate and fix the issue.

The console errors indicate that there are API response format issues and some endpoints are returning a 400 BAD REQUEST error. These errors typically stem from incorrect data parsing or unexpected response formats from the API.

Steps to Fix the Issue:
API Response Handling:
Ensure that you are correctly handling the API responses in your JavaScript. This involves checking that the responses are of the expected format before attempting to use them.

Modify API Endpoints:
Ensure that the APIs always return a predictable and accurate response format.

Fix the get_current_stores Function:
Ensure that the SQL queries and the data transformation logic in the API are returning data as expected.

Proposed Changes
I'll focus on the get_current_stores function from api_endpoints.py to ensure it queries and formats data correctly since the error messages suggest unexpected API response formats.

def get_current_stores():
    """
    最新の店舗データを取得するエンドポイント
    クエリパラメータ:
    - page: ページ番号（デフォルト: 1）
    - per_page: 1ページあたりの表示件数（0は全件表示）
    - お気に入りやフィルタリング条件を追加
    """
    page = request.args.get('page', 1, type=int)
    per_page = request.args.get('per_page', 0, type=int)  # If 0, fetch all
    biz_type = request.args.get('biz_type', '')
    genre = request.args.get('genre', '')
    area = request.args.get('area', '')
    sort = request.args.get('sort', 'rate')
    order = request.args.get('order', 'desc')
    search = request.args.get('search', '')
    favorites_str = request.args.get('favorites', '')
    favorites = [f.strip() for f in favorites_str.split(',') if f.strip()]
    try:
        query = """
        WITH latest_timestamps AS (
            SELECT store_name, MAX(timestamp) as latest_timestamp
            FROM store_status
            GROUP BY store_name
        )
        SELECT s.*, 
               CASE 
                   WHEN s.total_staff = 0 THEN 0
                   ELSE CAST(s.working_staff AS FLOAT) / s.total_staff
               END AS operation_rate
        FROM store_status s
        JOIN latest_timestamps lt
            ON s.store_name = lt.store_name AND s.timestamp = lt.latest_timestamp
        WHERE 1=1
        """
        params = []
        if search:
            query += " AND (s.store_name LIKE ? OR s.biz_type LIKE ? OR s.genre LIKE ? OR s.area LIKE ?)"
            search_param = f"%{search}%"
            params.extend([search_param] * 4)
        if biz_type:
            query += " AND s.biz_type = ?"
            params.append(biz_type)
        if genre:
            query += " AND s.genre = ?"
            params.append(genre)
        if area:
            query += " AND s.area = ?"
            params.append(area)
        if favorites:
            placeholders = ','.join(['?' for _ in favorites])
            query += f" AND s.store_name IN ({placeholders})"
            params.extend(favorites)
        
        if sort == 'name':
            query += f" ORDER BY s.store_name {'ASC' if order == 'asc' else 'DESC'}"
        elif sort == 'rate':
            query += f" ORDER BY operation_rate {'ASC' if order == 'asc' else 'DESC'}, s.store_name ASC"
        if per_page > 0:
            query += " LIMIT ? OFFSET ?"
            params.extend([per_page, (page - 1) * per_page])
        
        conn = get_db_connection()
        results = conn.execute(query, params).fetchall()
        conn.close()
        # Transform the results into a well-defined JSON format
        stores = [
            {'store_name': row['store_name'], 'operation_rate': row['operation_rate']}
            for row in results
        ]
        return api_response({'stores': stores})
    except Exception as e:
        logger.error(f"Error fetching store data: {e}")
        return error_response(f"データ取得中にエラーが発生しました: {str(e)}")
These adjustments ensure the API function get_current_stores() responds with a clear and expected JSON object. Check the JavaScript code to ensure it correctly parses this format.

If further issues persist, verify other API functions or JavaScript handling related to templates/integrated_dashboard.html. If changes are still needed, please provide more detailed requirements or contexts for further help.